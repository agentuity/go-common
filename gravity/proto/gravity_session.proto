syntax = "proto3";

package gravity;

import "google/protobuf/duration.proto";
import "google/protobuf/timestamp.proto";
import "gravity_metrics.proto"; // Import shared types

option go_package = "github.com/agentuity/go-common/gravity/proto";

// GravitySessionService handles session establishment and tunnel management
// using self-signed client certificates authenticated against the org's
// registered public key.
//
// This service replaces the legacy Provision + EstablishTunnel two-step flow
// with a single-step session establishment.
service GravitySessionService {
  // EstablishSession creates a bidirectional control stream.
  // Authentication is performed via mTLS using self-signed client certificates.
  // The client's certificate public key is verified against the org's registered key.
  rpc EstablishSession(stream SessionMessage) returns (stream SessionMessage);

  // StreamSessionPackets handles bidirectional packet data streaming.
  // Same as the legacy GravityTunnel.StreamPackets but on the new service.
  rpc StreamSessionPackets(stream TunnelPacket) returns (stream TunnelPacket);

  // GetDeploymentMetadata retrieves metadata for a deployment.
  rpc GetDeploymentMetadata(DeploymentMetadataRequest) returns (DeploymentMetadataResponse);

  // GetSandboxMetadata retrieves metadata for a sandbox.
  rpc GetSandboxMetadata(SandboxMetadataRequest) returns (SandboxMetadataResponse);

  // Identify performs a one-shot authentication to retrieve the org ID.
  // Authentication is performed via mTLS using self-signed client certificates.
  rpc Identify(IdentifyRequest) returns (IdentifyResponse);
}

// IdentifyRequest is sent by the client to identify the org associated with the key.
message IdentifyRequest {
  string instance_id = 1; // Instance ID (must match cert CN)
}

// IdentifyResponse contains the org ID from cert verification.
message IdentifyResponse {
  string org_id = 1; // Organization ID (from cert verification)
}

// SessionMessage is the bidirectional message type for EstablishSession.
// It contains all control plane messages for the session lifecycle.
message SessionMessage {
  string id = 1;
  string stream_id = 2; // Logical stream identifier for multiplexing

  oneof message_type {
    // Session lifecycle (10-19)
    SessionHello session_hello = 10;
    SessionHelloResponse session_hello_response = 11;
    SessionCloseRequest session_close = 15;

    // Deployment management (20-29)
    RouteDeploymentRequest route_deployment = 22;
    RouteDeploymentResponse route_deployment_response = 23;
    UnprovisionRequest unprovision = 25;
    RouteSandboxRequest route_sandbox = 26;
    RouteSandboxResponse route_sandbox_response = 27;

    // Health and monitoring (30-39)
    PingRequest ping = 30;
    PongResponse pong = 31;
    ReportRequest report = 32;

    // Session control (40-49)
    PauseRequest pause = 40;
    ResumeRequest resume = 41;

    // Configuration management (45-49)
    ConfigurationUpdate config_update = 45;
    ConfigurationUpdateResponse config_update_response = 46;

    // Generic protocol messages (50-59)
    ProtocolResponse response = 50;
    ProtocolEvent event = 51;

    // Evacuation / live migration (60-69)
    EvacuateRequest evacuate_request = 60;
    EvacuationPlan evacuation_plan = 61;
    SandboxCheckpointed sandbox_checkpointed = 62;
    RestoreSandboxTask restore_sandbox_task = 63;
    SandboxRestored sandbox_restored = 64;

    // Checkpoint URL requests (65-66) — presigned URL generation for suspend/resume
    CheckpointURLRequest checkpoint_url_request = 65;
    CheckpointURLResponse checkpoint_url_response = 66;
  }
}

// SessionHello is sent by the client as the first message after TLS handshake.
// The org_id and instance_id are extracted from the client certificate.
message SessionHello {
  int32 protocol_version = 1; // Protocol version number for compatibility
  string client_version = 2; // Version string of the client (e.g., SHA, semver)
  string client_name = 3; // Name of the client application (e.g., "hadron")
  repeated ExistingDeployment deployments = 4; // List of existing deployments to restore
  HostInfo host_info = 5; // Information about the host system
  ClientCapabilities capabilities = 6; // Client capabilities for this session

  // Instance metadata (extracted from cert but also sent for validation)
  string instance_id = 7; // Instance ID (must match cert CN)
}

// SessionHelloResponse is sent by the server after successful authentication.
message SessionHelloResponse {
  string machine_id = 1; // Deterministic machine ID assigned by server
  string org_id = 2; // Organization ID (from cert verification)
  string otlp_url = 3; // OpenTelemetry endpoint URL for metrics
  string otlp_key = 4; // OpenTelemetry API key for authentication
  string api_url = 5; // Base URL for API operations
  repeated string environment = 6; // Environment variables to set
  repeated HostMapping host_mapping = 7; // Host to IP address mappings
  repeated string subnet_routes = 8; // Subnet routes for the session
  string gravity_server = 9; // The gravity server that we're connected to
  string hostname = 10; // Dynamic hostname if requested
  bytes ssh_public_key = 11; // SSH public key for internal trusted connections
  string machine_token = 12; // JWT token for machine to authenticate with catalyst
  string machine_cert_bundle = 13; // PEM certificate bundle (cert, ca, key)
}

// SessionCloseRequest is sent to gracefully close the session.
message SessionCloseRequest {
  string reason = 1; // Reason for closing the session
}

// TunnelPacket represents network packet data for the tunnel
message TunnelPacket {
  bytes data = 1; // Raw IP packet data
  string stream_id = 2; // Logical stream identifier for multiplexing
}

// ClientCapabilities defines what capabilities a client supports
message ClientCapabilities {
  bool provision_deployments = 1; // Can handle provision deployment requests
  bool unprovision_deployments = 2; // Can handle unprovision deployment requests
  string dynamic_project_routing = 3; // Project ID for dynamic routing (empty = no routing)
  bool dynamic_hostname = 4; // Request dynamic hostname generation and routing
}

message RouteDeploymentRequest {
  string deployment_id = 1; // Unique identifier for the deployment
  string hostname = 2; // Deprecated: unused and will be removed
  string virtual_ip = 3; // Hadron virtual IP for the deployment
}

message RouteDeploymentResponse {
  string ip = 1;
}

// Unprovision request
message UnprovisionRequest {
  string deployment_id = 1; // Unique identifier of deployment to remove
}

// Report request for metrics
message ReportRequest {
  ServerMetrics metrics = 1; // Comprehensive server metrics and performance data
}

// Ping request for health checking
message PingRequest {
  google.protobuf.Timestamp timestamp = 1;
}

// Pong response
message PongResponse {
  google.protobuf.Timestamp timestamp = 1;
}

// Close request
message CloseRequest {
  string reason = 1; // Reason for closing the connection
}

// Pause request
message PauseRequest {
  string reason = 1; // Reason for pausing the session
}

// Resume request
message ResumeRequest {
  string reason = 1; // Reason for resuming the session
}

// Generic protocol response
message ProtocolResponse {
  string id = 1; // Unique identifier for the response
  string event = 2; // Event type this response is for
  bool success = 3; // Whether the operation was successful
  string error = 4; // Error message if operation failed
  bytes payload = 5; // Optional response payload data
}

// Generic protocol event (server-initiated)
message ProtocolEvent {
  string id = 1; // Unique identifier for the event
  string event = 2; // Event type being sent
  bytes payload = 3; // Event payload data
}

// Configuration update from server to client
message ConfigurationUpdate {
  string id = 1; // Unique identifier for tracking this update
  repeated ConfigItem config = 2; // List of configuration items to set
}

message ConfigItem {
  string key = 1; // Configuration key name
  string value = 2; // Configuration value
}

// Configuration update response from client to server
message ConfigurationUpdateResponse {
  string id = 1; // Identifier matching the ConfigurationUpdate
  bool success = 2; // Whether the configuration was successful
  string error = 3; // Error message if configuration failed
}

// Supporting data structures
message HostInfo {
  uint64 started = 1; // epoch time in milliseconds since server started
  uint32 cpu = 2; // number of CPUs
  uint64 memory = 3; // memory in bytes
  uint64 disk = 4; // disk free space in bytes
  string ipv4_address = 5; // IPv4 address
  string ipv6_address = 6; // IPv6 address
  string hostname = 7; // hostname
  string instance_id = 8; // instance id of the client
  string provider = 9; // Cloud provider (e.g., "aws", "gcp", "azure")
  string region = 10; // Cloud region
  string instance_type = 11; // instance type of the client (n1-standard-32, m6i.8xlarge)
  repeated string instance_tags = 12; // tags on the instance
  string availability_zone = 13; // the availability zone for the client
}

message ExistingDeployment {
  string id = 1; // Unique identifier for the deployment
  google.protobuf.Timestamp started = 3; // When the deployment was started
  string ipv6_address = 4; // Assigned IPv6 address for the deployment
  string org_id = 5;
  ResourceRequirements resources = 6; // CPU and memory requirements
  DeploymentCert deployment_cert = 7;
  bool used_private_key = 8; // Deployment used private key
  bool paused = 9;
  google.protobuf.Duration pausedDuration = 10;
  bool on_demand = 11;
  string cert = 12; // PEM certificate that was issued (just cert, ca + key not required)
}

message DeploymentSpec {
  // Deprecated but removing DeploymentSpec breaks wire compat
  option deprecated = true;
}

message ResourceRequirements {
  int64 memory_limit = 1; // Maximum memory in bytes
  int64 cpu_limit = 2; // Maximum CPU in millicores (1000 = 1 core)
  int64 memory_request = 3; // Requested memory in bytes
  int64 cpu_request = 4; // Requested CPU in millicores
  int64 disk_limit = 5; // Maximum storage in bytes
  int64 disk_request = 6; // Requested storage in bytes
}

message DeploymentCert {
  string cert = 1; // TLS certificate in PEM format
  string key = 2; // TLS private key in PEM format
  string ca = 3; // Certificate Authority certificate
  string dnsname = 4; // DNS name for the certificate
}

message CodeMetadata {
  repeated string env = 1; // Environment variable names
  repeated string secrets = 2; // Secret names required by the code
}

message HostMapping {
  string hostname = 1; // Hostname to map
  string ip_address = 2; // IP address to map the hostname to
}

// Deployment metadata request
message DeploymentMetadataRequest {
  string deployment_id = 1; // Unique identifier for the deployment
  string org_id = 2; // Organization identifier
}

// Deployment metadata response
message DeploymentMetadataResponse {
  bool success = 1; // Whether the request was successful
  string error = 2; // Error message if request failed
  CodeMetadata code_metadata = 3; // Code metadata from FetchEnv
  DeploymentCert deployment_cert = 4; // Generated deployment certificate
  string otlp_token = 5; // OpenTelemetry token for metrics
  string auth_token = 6; // Authentication token
  repeated string extra_hosts = 7; // Extra /etc/hosts entries for the deployment
  string cert_bundle = 8; // PEM certificate bundle (cert, ca, key)
}

message RouteSandboxRequest {
  string sandbox_id = 1;
  string virtual_ip = 2; // Hadron virtual IP for the sandbox
}

message RouteSandboxResponse {
  string ip = 1;
}

// Sandbox metadata request
message SandboxMetadataRequest {
  string sandbox_id = 1;
  string org_id = 2;
  bool generate_certificate = 3; // Whether to generate a certificate
}

// Sandbox metadata response
message SandboxMetadataResponse {
  bool success = 1; // Whether the request was successful
  string error = 2; // Error message if request failed
  repeated string extra_hosts = 3; // Extra /etc/hosts entries for the sandbox
  string cert_bundle = 4; // PEM certificate bundle (cert, ca, key)
}

// ================================
// Evacuation messages (60-69)
// Used for live migration of sandboxes between machines.
// ================================

// SandboxEvacInfo describes a sandbox that needs to be evacuated.
message SandboxEvacInfo {
  string sandbox_id = 1;
  string org_id = 2;
  string project_id = 3;
  int64 estimated_size = 4; // Estimated checkpoint bundle size in bytes
}

// EvacuateRequest is sent by Hadron to Gravity when it needs to evacuate sandboxes.
// Reasons include: machine shutdown, maintenance, or resource pressure.
message EvacuateRequest {
  string machine_id = 1;
  string reason = 2; // "shutdown", "maintenance", "resource_pressure"
  repeated SandboxEvacInfo sandboxes = 3;
}

// EvacuateSandboxPlan describes the plan for evacuating a single sandbox.
message EvacuateSandboxPlan {
  string sandbox_id = 1;
  string upload_url = 2; // Presigned S3 URL for uploading checkpoint bundle
  string destination_machine = 3; // May be empty (Gravity decides after upload)
}

// EvacuationPlan is sent by Gravity to the source Hadron with upload URLs and destination info.
message EvacuationPlan {
  repeated EvacuateSandboxPlan sandboxes = 1;
}

// SandboxCheckpointed is sent by source Hadron to Gravity after a sandbox has been checkpointed.
message SandboxCheckpointed {
  string sandbox_id = 1;
  string checkpoint_id = 2;
  string s3_key = 3;
  int64 bundle_size = 4;
  bool success = 5;
  string error = 6; // Error message if success=false
  bytes sandbox_spec = 7; // JSON-encoded SandboxSpec from source machine
}

// RestoreSandboxTask is sent by Gravity to the destination Hadron to restore a sandbox.
message RestoreSandboxTask {
  string sandbox_id = 1;
  string checkpoint_id = 2;
  string download_url = 3; // Presigned S3 URL for downloading checkpoint bundle
  string network_name = 4;
  bytes sandbox_spec = 5; // JSON-encoded SandboxSpec
  string org_id = 6;
  string project_id = 7;
}

// SandboxRestored is sent by destination Hadron to Gravity after a sandbox has been restored.
message SandboxRestored {
  string sandbox_id = 1;
  string ipv6_address = 2; // New IPv6 address on destination machine
  bool success = 3;
  string error = 4; // Error message if success=false
}

// Checkpoint URL operation type
enum CheckpointURLOperation {
  CHECKPOINT_URL_UPLOAD = 0;
  CHECKPOINT_URL_DOWNLOAD = 1;
}

// CheckpointURLRequest is sent by Hadron to Gravity to request a presigned S3 URL
// for checkpoint upload (suspend) or download (resume) operations.
// This enables centralized S3 bucket management — Hadron never needs S3 credentials.
message CheckpointURLRequest {
  string sandbox_id = 1;
  CheckpointURLOperation operation = 2;
  string checkpoint_key = 3; // For downloads: the S3 key to download. Empty for uploads (Gravity generates key).
}

// CheckpointURLResponse is sent by Gravity to Hadron with the presigned S3 URL.
message CheckpointURLResponse {
  string sandbox_id = 1;
  string presigned_url = 2;
  string checkpoint_key = 3; // The S3 object key (for uploads: Gravity-generated; for downloads: echoed back)
  int64 expiry_seconds = 4;  // How long the presigned URL is valid
  bool success = 5;
  string error = 6;          // Error message if success=false
}
