package dns

import (
	"os"
	"path/filepath"
	"strings"
	"testing"
)

func TestWriteResolvConf(t *testing.T) {
	// Create a temporary directory for test files
	tmpDir := t.TempDir()

	tests := []struct {
		name     string
		filename string
		wantErr  bool
	}{
		{
			name:     "write to custom file",
			filename: filepath.Join(tmpDir, "resolv.conf"),
			wantErr:  false,
		},
		{
			name:     "write to nested directory",
			filename: filepath.Join(tmpDir, "etc", "resolv.conf"),
			wantErr:  true, // Directory doesn't exist
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := WriteResolvConf(tt.filename)
			if (err != nil) != tt.wantErr {
				t.Errorf("WriteResolvConf() error = %v, wantErr %v", err, tt.wantErr)
				return
			}

			if !tt.wantErr {
				// Read the file and verify contents
				content, err := os.ReadFile(tt.filename)
				if err != nil {
					t.Fatalf("Failed to read written file: %v", err)
				}

				contentStr := string(content)

				// Verify it contains the nameserver line
				if !strings.Contains(contentStr, "nameserver 127.0.0.1") {
					t.Error("resolv.conf does not contain 'nameserver 127.0.0.1'")
				}

				// Verify it contains the search domain
				expectedSearch := "search " + DefaultInternalDomain
				if !strings.Contains(contentStr, expectedSearch) {
					t.Errorf("resolv.conf does not contain '%s'", expectedSearch)
				}

				// Verify it contains the comment
				if !strings.Contains(contentStr, "# Generated by agentuity/go-common/dns") {
					t.Error("resolv.conf does not contain generation comment")
				}
			}
		})
	}
}

func TestWriteResolvConf_DefaultPath(t *testing.T) {
	// We can't actually write to /etc/resolv.conf in tests,
	// but we can test that the default path is used by passing empty string
	// This test just ensures the function doesn't panic with empty filename

	// Create a temporary directory and change to it
	tmpDir := t.TempDir()
	testFile := filepath.Join(tmpDir, "test-resolv.conf")

	// Call with non-empty filename to avoid actual /etc/resolv.conf
	err := WriteResolvConf(testFile)
	if err != nil {
		t.Fatalf("WriteResolvConf() with custom path failed: %v", err)
	}

	// Verify the file was created
	if _, err := os.Stat(testFile); os.IsNotExist(err) {
		t.Error("resolv.conf file was not created")
	}
}

func TestWriteResolvConf_Content(t *testing.T) {
	tmpDir := t.TempDir()
	testFile := filepath.Join(tmpDir, "resolv.conf")

	err := WriteResolvConf(testFile)
	if err != nil {
		t.Fatalf("WriteResolvConf() failed: %v", err)
	}

	// Read and parse the file
	content, err := os.ReadFile(testFile)
	if err != nil {
		t.Fatalf("Failed to read written file: %v", err)
	}

	lines := strings.Split(string(content), "\n")

	// Track what we found
	foundComment := false
	foundNameserver := false
	foundSearch := false

	for _, line := range lines {
		line = strings.TrimSpace(line)
		if strings.HasPrefix(line, "#") {
			foundComment = true
		}
		if strings.HasPrefix(line, "nameserver 127.0.0.1") {
			foundNameserver = true
		}
		if strings.HasPrefix(line, "search "+DefaultInternalDomain) {
			foundSearch = true
		}
	}

	if !foundComment {
		t.Error("resolv.conf missing comment header")
	}
	if !foundNameserver {
		t.Error("resolv.conf missing nameserver line")
	}
	if !foundSearch {
		t.Error("resolv.conf missing search line")
	}
}

func TestWriteResolvConf_FilePermissions(t *testing.T) {
	tmpDir := t.TempDir()
	testFile := filepath.Join(tmpDir, "resolv.conf")

	err := WriteResolvConf(testFile)
	if err != nil {
		t.Fatalf("WriteResolvConf() failed: %v", err)
	}

	// Check file permissions
	info, err := os.Stat(testFile)
	if err != nil {
		t.Fatalf("Failed to stat file: %v", err)
	}

	mode := info.Mode().Perm()
	expectedMode := os.FileMode(0644)

	if mode != expectedMode {
		t.Errorf("File permissions = %o, want %o", mode, expectedMode)
	}
}

func TestParseResolvConf(t *testing.T) {
	tests := []struct {
		name            string
		content         string
		wantNameservers []string
		wantSearch      []string
		wantErr         bool
	}{
		{
			name: "standard resolv.conf",
			content: `# This is a comment
nameserver 8.8.8.8
nameserver 8.8.4.4
search example.com local
`,
			wantNameservers: []string{"8.8.8.8:53", "8.8.4.4:53"},
			wantSearch:      []string{"example.com", "local"},
			wantErr:         false,
		},
		{
			name: "skip loopback 127.0.0.1",
			content: `nameserver 127.0.0.1
nameserver 10.0.2.3
nameserver 8.8.8.8
`,
			wantNameservers: []string{"10.0.2.3:53", "8.8.8.8:53"},
			wantSearch:      nil,
			wantErr:         false,
		},
		{
			name: "skip all loopback variants",
			content: `nameserver 127.0.0.1
nameserver 127.0.0.53
nameserver 127.1.1.1
nameserver 10.0.2.3
`,
			wantNameservers: []string{"10.0.2.3:53"},
			wantSearch:      nil,
			wantErr:         false,
		},
		{
			name: "skip IPv6 loopback",
			content: `nameserver ::1
nameserver 10.0.2.3
`,
			wantNameservers: []string{"10.0.2.3:53"},
			wantSearch:      nil,
			wantErr:         false,
		},
		{
			name: "podman style with slirp4netns",
			content: `# Generated by Podman
nameserver 10.0.2.3
search dns.podman
`,
			wantNameservers: []string{"10.0.2.3:53"},
			wantSearch:      []string{"dns.podman"},
			wantErr:         false,
		},
		{
			name: "multiple search domains",
			content: `nameserver 192.168.1.1
search corp.example.com example.com localdomain
`,
			wantNameservers: []string{"192.168.1.1:53"},
			wantSearch:      []string{"corp.example.com", "example.com", "localdomain"},
			wantErr:         false,
		},
		{
			name:            "empty file",
			content:         "",
			wantNameservers: nil,
			wantSearch:      nil,
			wantErr:         false,
		},
		{
			name: "only comments",
			content: `# comment 1
; comment 2
# comment 3
`,
			wantNameservers: nil,
			wantSearch:      nil,
			wantErr:         false,
		},
		{
			name: "all loopback - no valid nameservers",
			content: `nameserver 127.0.0.1
nameserver 127.0.0.53
`,
			wantNameservers: nil,
			wantSearch:      nil,
			wantErr:         false,
		},
		{
			name: "extra whitespace",
			content: `  nameserver   8.8.8.8  
  search   example.com  
`,
			wantNameservers: []string{"8.8.8.8:53"},
			wantSearch:      []string{"example.com"},
			wantErr:         false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Create temp file with content
			tmpDir := t.TempDir()
			testFile := filepath.Join(tmpDir, "resolv.conf")
			if err := os.WriteFile(testFile, []byte(tt.content), 0644); err != nil {
				t.Fatalf("Failed to write test file: %v", err)
			}

			got, err := ParseResolvConf(testFile)
			if (err != nil) != tt.wantErr {
				t.Errorf("ParseResolvConf() error = %v, wantErr %v", err, tt.wantErr)
				return
			}

			if !tt.wantErr {
				// Compare nameservers
				if len(got.Nameservers) != len(tt.wantNameservers) {
					t.Errorf("ParseResolvConf() nameservers = %v, want %v", got.Nameservers, tt.wantNameservers)
				} else {
					for i, ns := range got.Nameservers {
						if ns != tt.wantNameservers[i] {
							t.Errorf("ParseResolvConf() nameserver[%d] = %v, want %v", i, ns, tt.wantNameservers[i])
						}
					}
				}

				// Compare search domains
				if len(got.Search) != len(tt.wantSearch) {
					t.Errorf("ParseResolvConf() search = %v, want %v", got.Search, tt.wantSearch)
				} else {
					for i, s := range got.Search {
						if s != tt.wantSearch[i] {
							t.Errorf("ParseResolvConf() search[%d] = %v, want %v", i, s, tt.wantSearch[i])
						}
					}
				}
			}
		})
	}
}

func TestParseResolvConf_FileNotFound(t *testing.T) {
	_, err := ParseResolvConf("/nonexistent/path/resolv.conf")
	if err == nil {
		t.Error("ParseResolvConf() expected error for nonexistent file, got nil")
	}
}

func TestIsLoopbackAddress(t *testing.T) {
	tests := []struct {
		addr string
		want bool
	}{
		{"127.0.0.1", true},
		{"127.0.0.53", true},
		{"127.1.1.1", true},
		{"127.255.255.255", true},
		{"::1", true},
		{"10.0.2.3", false},
		{"192.168.1.1", false},
		{"8.8.8.8", false},
		{"1.1.1.1", false},
		{"0.0.0.0", false},
		{"", false},
		{"invalid", false},
	}

	for _, tt := range tests {
		t.Run(tt.addr, func(t *testing.T) {
			if got := isLoopbackAddress(tt.addr); got != tt.want {
				t.Errorf("isLoopbackAddress(%q) = %v, want %v", tt.addr, got, tt.want)
			}
		})
	}
}

func TestGetSystemNameservers_Merging(t *testing.T) {
	// Save original default and restore after test
	origDefault := DefaultResolveConfFilename
	defer func() { DefaultResolveConfFilename = origDefault }()

	// Create a temp resolv.conf with custom nameservers
	tmpDir := t.TempDir()
	testFile := filepath.Join(tmpDir, "resolv.conf")
	content := `nameserver 10.0.2.3
nameserver 192.168.1.1
`
	if err := os.WriteFile(testFile, []byte(content), 0644); err != nil {
		t.Fatalf("Failed to write test file: %v", err)
	}

	DefaultResolveConfFilename = testFile

	result := GetSystemNameservers()

	// Should have system nameservers first, then defaults
	if len(result) < 2 {
		t.Fatalf("Expected at least 2 nameservers, got %d: %v", len(result), result)
	}

	// First two should be from the file
	if result[0] != "10.0.2.3:53" {
		t.Errorf("Expected first nameserver to be 10.0.2.3:53, got %s", result[0])
	}
	if result[1] != "192.168.1.1:53" {
		t.Errorf("Expected second nameserver to be 192.168.1.1:53, got %s", result[1])
	}

	// Should also include defaults as fallbacks
	hasDefault := false
	for _, ns := range result {
		for _, def := range DefaultExternalDNSServers {
			if ns == def {
				hasDefault = true
				break
			}
		}
	}
	if !hasDefault {
		t.Error("Expected default nameservers to be included as fallbacks")
	}
}

func TestGetSystemNameservers_NoDuplicates(t *testing.T) {
	// Save original default and restore after test
	origDefault := DefaultResolveConfFilename
	defer func() { DefaultResolveConfFilename = origDefault }()

	// Create a temp resolv.conf that includes one of the defaults
	tmpDir := t.TempDir()
	testFile := filepath.Join(tmpDir, "resolv.conf")
	content := `nameserver 9.9.9.9
nameserver 10.0.2.3
`
	if err := os.WriteFile(testFile, []byte(content), 0644); err != nil {
		t.Fatalf("Failed to write test file: %v", err)
	}

	DefaultResolveConfFilename = testFile

	result := GetSystemNameservers()

	// Count occurrences of 9.9.9.9:53
	count := 0
	for _, ns := range result {
		if ns == "9.9.9.9:53" {
			count++
		}
	}

	if count != 1 {
		t.Errorf("Expected 9.9.9.9:53 to appear exactly once, got %d times in %v", count, result)
	}
}
